#!/usr/bin/env python
# vim: set noet sw=4 ts=4:

import sys
import os
import optparse
import logging
import traceback

# If we're running from an SVN checkout, tweak the path to find the main
# module from the checkout in preference to any that may be installed in the
# system's library
mypath = os.path.dirname(sys.argv[0])
if (os.path.exists(os.path.join(mypath, '.svn')) and
		os.path.exists(os.path.join(mypath, '..', 'db2makedoc'))):
	sys.path.insert(0, os.path.realpath(os.path.join(mypath, '..')))

from db2makedoc.highlighters import SQLHighlighter

__version__ = "1.0.0"

def main(args=None):
	if args is None:
		args = sys.argv[1:]
	# Parse the command line arguments
	parser = optparse.OptionParser(
		usage='%prog [options] files...',
		version='%%prog %s SQL reformatter' % __version__,
		description="""\
This utility reformats SQL for human consumption using the same parser that the
db2makedoc application uses for generating SQL in documentation. Either specify
the name of a file containing the SQL to reformat, or specify - to indicate
that stdin should be read. The reformatted SQL will be written to stdout in
either case. The available command line options are listed below.""")
	parser.set_defaults(
		debug=False,
		terminator=';',
		loglevel=logging.WARNING
	)
	parser.add_option('-q', '--quiet', dest='loglevel', action='store_const', const=logging.ERROR,
		help="""produce less console output""")
	parser.add_option('-v', '--verbose', dest='loglevel', action='store_const', const=logging.DEBUG,
		help="""produce more console output""")
	parser.add_option('-t', '--terminator', dest='terminator',
		help="""specify the statement terminator (default=';')""")
	parser.add_option('-D', '--debug', dest='debug', action='store_true',
		help="""enables debug mode (lots more output and always prints stack trace in case of failure)""")
	(options, args) = parser.parse_args(args)
	# Set up some logging stuff
	console = logging.StreamHandler(sys.stderr)
	console.setFormatter(logging.Formatter('%(message)s'))
	console.setLevel(options.loglevel)
	logging.getLogger().addHandler(console)
	# Set up the exceptions hook for uncaught exceptions and the logging
	# levels if --debug was given
	if options.debug:
		console.setLevel(logging.DEBUG)
		logging.getLogger().setLevel(logging.DEBUG)
	else:
		logging.getLogger().setLevel(logging.INFO)
		sys.excepthook = production_excepthook
	# Call one of the action routines depending on the options
	done_stdin = False
	highlighter = SQLHighlighter()
	for sql_file in args:
		if sql_file == '-':
			if not done_stdin:
				done_stdin = True
				sql_file = sys.stdin
			else:
				raise IOError('Cannot read input from stdin multiple times')
		else:
			sql_file = open(sql_file, 'rU')
		sql = sql_file.read()
		sql = ''.join(highlighter.parse(sql, terminator=options.terminator))
		sys.stdout.write(sql)
		sys.stdout.flush()

def production_excepthook(type, value, tb):
	"""Exception hook for non-debug mode."""
	# I/O errors and plugin errors should be simple to solve - no need to
	# bother the user with a full stack trace, just the error message will
	# suffice. Same for user interrupts
	if issubclass(type, (IOError, KeyboardInterrupt)):
		logging.critical(str(value))
	else:
		# Otherwise, log the stack trace and the exception into the log file
		# for debugging purposes
		for line in traceback.format_exception(type, value, tb):
			for s in line.rstrip().split('\n'):
				logging.critical(s)
	# Pass a failure exit code to the calling shell
	sys.exit(1)

if __name__ == '__main__':
	main()
